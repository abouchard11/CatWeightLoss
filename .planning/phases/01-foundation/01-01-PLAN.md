---
phase: 01-foundation
plan: 01
type: execute
---

<objective>
Replace fatalError() in ModelContainer initialization with graceful error recovery.

Purpose: Prevent app crash when database is corrupted or schema migration fails.
Output: App displays error view with recovery option instead of crashing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-phase.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/CONVENTIONS.md
@CatWeightLoss/CatWeightLossApp.swift

**Problem:** Lines 23-27 use `fatalError()` which crashes app if ModelContainer fails.
**Pattern:** Use @State for error state, show DatabaseErrorView when error occurs.
**Constraint:** Zero external dependencies (Apple frameworks only).
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DatabaseErrorView component</name>
  <files>CatWeightLoss/Components/DatabaseErrorView.swift</files>
  <action>
Create a SwiftUI view that displays when database initialization fails:
- Shows SF Symbol "exclamationmark.triangle.fill" in orange
- Title: "Unable to Load Data"
- Subtitle explaining the issue (from error.localizedDescription)
- "Try Again" button that calls a retry closure
- Optional "Reset Data" button (with confirmation alert) that deletes the database file and retries

Follow existing component patterns (see StatCard.swift, ActionButton.swift for style).
Do NOT add external error tracking - keep it simple and local.
  </action>
  <verify>File exists at CatWeightLoss/Components/DatabaseErrorView.swift, compiles without errors</verify>
  <done>DatabaseErrorView component exists with retry and reset functionality</done>
</task>

<task type="auto">
  <name>Task 2: Refactor CatWeightLossApp for graceful error handling</name>
  <files>CatWeightLoss/CatWeightLossApp.swift</files>
  <action>
Replace fatalError pattern with error state:

1. Add @State private var databaseError: Error? = nil
2. Change sharedModelContainer to optional (ModelContainer?)
3. Create initializeDatabase() function that:
   - Tries to create ModelContainer
   - On success: sets sharedModelContainer
   - On failure: sets databaseError
4. In body, check for databaseError first:
   - If error: show DatabaseErrorView with retry closure
   - If no container yet: show ProgressView("Loading...")
   - If container ready: show normal content
5. Remove fatalError() entirely

Do NOT use Result type for stored property - use separate optionals for cleaner SwiftUI state management.
  </action>
  <verify>
Build succeeds: xcodebuild -project CatWeightLoss.xcodeproj -scheme CatWeightLoss -destination 'platform=iOS Simulator,name=iPhone 16' build
  </verify>
  <done>App builds without fatalError, shows error view on database failure, normal flow on success</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] xcodebuild build succeeds without errors
- [ ] No fatalError() calls remain in CatWeightLossApp.swift
- [ ] DatabaseErrorView.swift exists and follows component conventions
- [ ] App launches normally in simulator
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- fatalError() eliminated from app initialization
- Error recovery UI exists
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
